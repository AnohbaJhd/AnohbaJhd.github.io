<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dijkstra's Algorithm: Your GPS for the World of Graphs | Anohba Jehad</title><meta name=keywords content="dijkstra,algorithm,ubuntu,graphs"><meta name=description content="Introduction
Dijkstraâ€™s Algorithm is a popular and efficient algorithm used for finding the shortest path from a single source node to all other nodes in a weighted graph. It is widely used in network routing, mapping applications, and many areas of computer science.

What Is Dijkstraâ€™s Algorithm?
Dijkstraâ€™s Algorithm solves the single-source shortest path problem in a graph with non-negative edge weights. It finds the shortest path from a starting node (source) to every other node in the graph."><meta name=author content><link rel=canonical href=https://anohbahjd.github.io/posts/dijkstra/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://anohbahjd.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://anohbahjd.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://anohbahjd.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://anohbahjd.github.io/apple-touch-icon.png><link rel=mask-icon href=https://anohbahjd.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://anohbahjd.github.io/posts/dijkstra/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://anohbahjd.github.io/posts/dijkstra/"><meta property="og:site_name" content="Anohba Jehad"><meta property="og:title" content="Dijkstra's Algorithm: Your GPS for the World of Graphs"><meta property="og:description" content="Introduction Dijkstraâ€™s Algorithm is a popular and efficient algorithm used for finding the shortest path from a single source node to all other nodes in a weighted graph. It is widely used in network routing, mapping applications, and many areas of computer science.
What Is Dijkstraâ€™s Algorithm? Dijkstraâ€™s Algorithm solves the single-source shortest path problem in a graph with non-negative edge weights. It finds the shortest path from a starting node (source) to every other node in the graph."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-01T00:46:56+05:00"><meta property="article:modified_time" content="2025-05-01T00:46:56+05:00"><meta property="article:tag" content="Dijkstra"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Ubuntu"><meta property="article:tag" content="Graphs"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dijkstra's Algorithm: Your GPS for the World of Graphs"><meta name=twitter:description content="Introduction
Dijkstraâ€™s Algorithm is a popular and efficient algorithm used for finding the shortest path from a single source node to all other nodes in a weighted graph. It is widely used in network routing, mapping applications, and many areas of computer science.

What Is Dijkstraâ€™s Algorithm?
Dijkstraâ€™s Algorithm solves the single-source shortest path problem in a graph with non-negative edge weights. It finds the shortest path from a starting node (source) to every other node in the graph."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://anohbahjd.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Dijkstra's Algorithm: Your GPS for the World of Graphs","item":"https://anohbahjd.github.io/posts/dijkstra/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dijkstra's Algorithm: Your GPS for the World of Graphs","name":"Dijkstra\u0027s Algorithm: Your GPS for the World of Graphs","description":"Introduction Dijkstraâ€™s Algorithm is a popular and efficient algorithm used for finding the shortest path from a single source node to all other nodes in a weighted graph. It is widely used in network routing, mapping applications, and many areas of computer science.\nWhat Is Dijkstraâ€™s Algorithm? Dijkstraâ€™s Algorithm solves the single-source shortest path problem in a graph with non-negative edge weights. It finds the shortest path from a starting node (source) to every other node in the graph.\n","keywords":["dijkstra","algorithm","ubuntu","graphs"],"articleBody":"Introduction Dijkstraâ€™s Algorithm is a popular and efficient algorithm used for finding the shortest path from a single source node to all other nodes in a weighted graph. It is widely used in network routing, mapping applications, and many areas of computer science.\nWhat Is Dijkstraâ€™s Algorithm? Dijkstraâ€™s Algorithm solves the single-source shortest path problem in a graph with non-negative edge weights. It finds the shortest path from a starting node (source) to every other node in the graph.\nKey Characteristics Graph Type: Works on both directed and undirected graphs. Directed Graph (Digraph) A directed graph has edges with a direction â€” like a one-way street. Each edge goes from one node to another specific node. Example: If thereâ€™s an edge from A to B, it doesnâ€™t mean you can go from B to A unless thereâ€™s a separate edge for that.\nðŸ¡’ Notation: A â†’ B Undirected Graph An undirected graph has edges without direction â€” like a two-way street. If thereâ€™s an edge between two nodes, you can move in both directions.\nExample: If thereâ€™s an edge between A and B, you can go from A to B and also from B to A.\nðŸ¡’ Notation: A â€” B\nEdge Weights: Requires all edge weights to be non-negative.\nOptimality: Guarantees the shortest path from the source to every other node.\nGreedy Approach: Selects the node with the smallest known distance at each step.\nTerminologies Node/Vertex: A point in the graph. Edge: A connection between two nodes. Weight: The cost to travel between two connected nodes. Visited Set: Nodes whose shortest distance from the source is finalized. Distance Map: Stores the currently known shortest distance from the source to each node. How the Algorithm Works Initialization Set the distance to the source node as 0. Set the distance to all other nodes as âˆž (infinity). Keep all nodes as unvisited. Create a priority queue or min-heap to fetch the node with the smallest distance. Priority Queue: A priority queue is like a line where each item has a number (priority), and the item with the smallest number gets picked first â€” not just the one who came first. In Dijkstraâ€™s Algorithm, it helps quickly find the next closest node to visit.\nMain Loop Pick the unvisited node with the smallest known distance. For each of its neighbors: Calculate the new distance using:\nnew_distance = current_distance + edge_weight If new_distance is less than the known distance, update it. Mark the current node as visited. Repeat until all nodes are visited or the shortest path is found. Example Given the following weighted graph:\nA ---3--- B | | 1 2 | | C ---4--- D Starting from A:\nInitial distances: A = 0, B = âˆž, C = âˆž, D = âˆž Visit A: Update B = 3, C = 1 Visit C: Update D = 1 + 4 = 5 Visit B: Update D = min(5, 3 + 2) = 5 (no change) Final distances: A = 0, B = 3, C = 1, D = 5 Why Dijkstra Does Not Support Negative Weights Dijkstraâ€™s Algorithm assumes that once the shortest path to a node is found, it will not change. This assumption fails with negative weights, where a shorter path might appear later. Therefore, the algorithm does not work correctly with negative-weight edges.\nComparison with Other Algorithms Algorithm Handles Negative Weights Use Case Dijkstra No Fastest for non-negative weights Bellman-Ford Yes Used when graph may contain negative weights Floyd-Warshall Yes Computes all-pairs shortest paths A* Search (typically) Best for pathfinding with a known goal Applications GPS and Navigation systems Network routing protocols (e.g., OSPF) Robot and AI pathfinding Traffic simulation Flight scheduling systems Summary Dijkstraâ€™s Algorithm is used to find the shortest paths from a single source node to all other nodes. It works only with non-negative edge weights. The algorithm uses a greedy approach and a priority queue for efficiency. Itâ€™s fast, reliable, and widely used in real-world applications. ","wordCount":"661","inLanguage":"en","datePublished":"2025-05-01T00:46:56+05:00","dateModified":"2025-05-01T00:46:56+05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://anohbahjd.github.io/posts/dijkstra/"},"publisher":{"@type":"Organization","name":"Anohba Jehad","logo":{"@type":"ImageObject","url":"https://anohbahjd.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://anohbahjd.github.io/ accesskey=h title="Anohba Jehad (Alt + H)">Anohba Jehad</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://anohbahjd.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://anohbahjd.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://anohbahjd.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://anohbahjd.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Dijkstra's Algorithm: Your GPS for the World of Graphs</h1><div class=post-meta><span title='2025-05-01 00:46:56 +0500 PKT'>May 1, 2025</span>&nbsp;Â·&nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#what-is-dijkstras-algorithm aria-label="What Is Dijkstraâ€™s Algorithm?">What Is Dijkstraâ€™s Algorithm?</a></li><li><a href=#key-characteristics aria-label="Key Characteristics">Key Characteristics</a><ul><li><a href=#directed-graph-digraph aria-label="Directed Graph (Digraph)">Directed Graph (Digraph)</a></li><li><a href=#undirected-graph aria-label="Undirected Graph">Undirected Graph</a></li></ul></li><li><a href=#terminologies aria-label=Terminologies>Terminologies</a></li><li><a href=#how-the-algorithm-works aria-label="How the Algorithm Works">How the Algorithm Works</a><ul><li><a href=#initialization aria-label=Initialization>Initialization</a></li><li><a href=#main-loop aria-label="Main Loop">Main Loop</a></li></ul></li><li><a href=#example aria-label=Example>Example</a></li><li><a href=#why-dijkstra-does-not-support-negative-weights aria-label="Why Dijkstra Does Not Support Negative Weights">Why Dijkstra Does Not Support Negative Weights</a></li><li><a href=#comparison-with-other-algorithms aria-label="Comparison with Other Algorithms">Comparison with Other Algorithms</a></li><li><a href=#applications aria-label=Applications>Applications</a></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>Dijkstraâ€™s Algorithm is a popular and efficient algorithm used for finding the shortest path from a single source node to all other nodes in a weighted graph. It is widely used in network routing, mapping applications, and many areas of computer science.</p><hr><h2 id=what-is-dijkstras-algorithm>What Is Dijkstraâ€™s Algorithm?<a hidden class=anchor aria-hidden=true href=#what-is-dijkstras-algorithm>#</a></h2><p>Dijkstraâ€™s Algorithm solves the single-source shortest path problem in a graph with <strong>non-negative edge weights</strong>. It finds the shortest path from a starting node (source) to every other node in the graph.</p><hr><h2 id=key-characteristics>Key Characteristics<a hidden class=anchor aria-hidden=true href=#key-characteristics>#</a></h2><ul><li><strong>Graph Type</strong>: Works on both directed and undirected graphs.</li></ul><h3 id=directed-graph-digraph>Directed Graph (Digraph)<a hidden class=anchor aria-hidden=true href=#directed-graph-digraph>#</a></h3><ul><li>A directed graph has edges with a direction â€” like a one-way street. Each edge goes from one node to another specific node.</li><li>Example: If thereâ€™s an edge from A to B, it doesn&rsquo;t mean you can go from B to A unless there&rsquo;s a separate edge for that.<br>ðŸ¡’ Notation: <strong>A â†’ B</strong></li></ul><h3 id=undirected-graph>Undirected Graph<a hidden class=anchor aria-hidden=true href=#undirected-graph>#</a></h3><ul><li><p>An undirected graph has edges without direction â€” like a two-way street. If there&rsquo;s an edge between two nodes, you can move in both directions.</p></li><li><p>Example: If there&rsquo;s an edge between A and B, you can go from A to B and also from B to A.<br>ðŸ¡’ Notation: <strong>A â€” B</strong></p></li><li><p><strong>Edge Weights</strong>: Requires all edge weights to be non-negative.</p></li><li><p><strong>Optimality</strong>: Guarantees the shortest path from the source to every other node.</p></li><li><p><strong>Greedy Approach</strong>: Selects the node with the smallest known distance at each step.</p></li></ul><hr><h2 id=terminologies>Terminologies<a hidden class=anchor aria-hidden=true href=#terminologies>#</a></h2><ul><li><strong>Node/Vertex</strong>: A point in the graph.</li><li><strong>Edge</strong>: A connection between two nodes.</li><li><strong>Weight</strong>: The cost to travel between two connected nodes.</li><li><strong>Visited Set</strong>: Nodes whose shortest distance from the source is finalized.</li><li><strong>Distance Map</strong>: Stores the currently known shortest distance from the source to each node.</li></ul><hr><h2 id=how-the-algorithm-works>How the Algorithm Works<a hidden class=anchor aria-hidden=true href=#how-the-algorithm-works>#</a></h2><h3 id=initialization>Initialization<a hidden class=anchor aria-hidden=true href=#initialization>#</a></h3><ul><li>Set the distance to the source node as <code>0</code>.</li><li>Set the distance to all other nodes as <code>âˆž</code> (infinity).</li><li>Keep all nodes as unvisited.</li><li>Create a priority queue or min-heap to fetch the node with the smallest distance.</li></ul><blockquote><p><strong>Priority Queue</strong>: A priority queue is like a line where each item has a number (priority), and the item with the smallest number gets picked first â€” not just the one who came first. In Dijkstraâ€™s Algorithm, it helps quickly find the next closest node to visit.</p></blockquote><hr><h3 id=main-loop>Main Loop<a hidden class=anchor aria-hidden=true href=#main-loop>#</a></h3><ol><li>Pick the unvisited node with the smallest known distance.</li><li>For each of its neighbors:<ul><li>Calculate the new distance using:<br><code>new_distance = current_distance + edge_weight</code></li><li>If <code>new_distance</code> is less than the known distance, update it.</li></ul></li><li>Mark the current node as visited.</li><li>Repeat until all nodes are visited or the shortest path is found.</li></ol><hr><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>Given the following weighted graph:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>A ---3--- B  
</span></span><span style=display:flex><span>|         |  
</span></span><span style=display:flex><span>1         2  
</span></span><span style=display:flex><span>|         |  
</span></span><span style=display:flex><span>C ---4--- D
</span></span></code></pre></div><p><strong>Starting from A:</strong></p><ul><li>Initial distances: A = 0, B = âˆž, C = âˆž, D = âˆž</li><li>Visit A: Update B = 3, C = 1</li><li>Visit C: Update D = 1 + 4 = 5</li><li>Visit B: Update D = min(5, 3 + 2) = 5 (no change)</li><li>Final distances: A = 0, B = 3, C = 1, D = 5</li></ul><hr><h2 id=why-dijkstra-does-not-support-negative-weights>Why Dijkstra Does Not Support Negative Weights<a hidden class=anchor aria-hidden=true href=#why-dijkstra-does-not-support-negative-weights>#</a></h2><p>Dijkstraâ€™s Algorithm assumes that once the shortest path to a node is found, it will not change. This assumption fails with <strong>negative weights</strong>, where a shorter path might appear later. Therefore, the algorithm does <strong>not work correctly with negative-weight edges</strong>.</p><hr><h2 id=comparison-with-other-algorithms>Comparison with Other Algorithms<a hidden class=anchor aria-hidden=true href=#comparison-with-other-algorithms>#</a></h2><table><thead><tr><th>Algorithm</th><th>Handles Negative Weights</th><th>Use Case</th></tr></thead><tbody><tr><td>Dijkstra</td><td>No</td><td>Fastest for non-negative weights</td></tr><tr><td>Bellman-Ford</td><td>Yes</td><td>Used when graph may contain negative weights</td></tr><tr><td>Floyd-Warshall</td><td>Yes</td><td>Computes all-pairs shortest paths</td></tr><tr><td>A* Search</td><td>(typically)</td><td>Best for pathfinding with a known goal</td></tr></tbody></table><hr><h2 id=applications>Applications<a hidden class=anchor aria-hidden=true href=#applications>#</a></h2><ul><li>GPS and Navigation systems</li><li>Network routing protocols (e.g., OSPF)</li><li>Robot and AI pathfinding</li><li>Traffic simulation</li><li>Flight scheduling systems</li></ul><hr><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><ul><li>Dijkstraâ€™s Algorithm is used to find the shortest paths from a single source node to all other nodes.</li><li>It works only with non-negative edge weights.</li><li>The algorithm uses a greedy approach and a priority queue for efficiency.</li><li>Itâ€™s fast, reliable, and widely used in real-world applications.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://anohbahjd.github.io/tags/dijkstra/>Dijkstra</a></li><li><a href=https://anohbahjd.github.io/tags/algorithm/>Algorithm</a></li><li><a href=https://anohbahjd.github.io/tags/ubuntu/>Ubuntu</a></li><li><a href=https://anohbahjd.github.io/tags/graphs/>Graphs</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://anohbahjd.github.io/>Anohba Jehad</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>