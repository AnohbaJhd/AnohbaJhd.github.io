<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Huffman Coding: The Art of Compression | Anohba Jehad</title>
<meta name="keywords" content="huffman, algorithm, ubuntu, greedy, coding">
<meta name="description" content="In a world drowning in data, how do we store and transmit information more efficiently? The answer lies in Huffman Coding — a beautifully simple yet powerful algorithm used for lossless data compression. It&rsquo;s been a cornerstone since it was introduced.

What Is Huffman Coding?
Huffman Coding is a greedy algorithm used to compress data without losing any information. The idea is simple:
Assign shorter codes to more frequent characters and longer codes to less frequent ones.
Ever tried zipping a file to save space? That magic trick behind the scenes? That’s compression — and Huffman Coding is one of the smartest ways to pull it off.">
<meta name="author" content="">
<link rel="canonical" href="https://AnohbaJhd.github.io/posts/huffman/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://AnohbaJhd.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://AnohbaJhd.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://AnohbaJhd.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://AnohbaJhd.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://AnohbaJhd.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://AnohbaJhd.github.io/posts/huffman/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://AnohbaJhd.github.io/posts/huffman/">
  <meta property="og:site_name" content="Anohba Jehad">
  <meta property="og:title" content="Huffman Coding: The Art of Compression">
  <meta property="og:description" content="In a world drowning in data, how do we store and transmit information more efficiently? The answer lies in Huffman Coding — a beautifully simple yet powerful algorithm used for lossless data compression. It’s been a cornerstone since it was introduced.
What Is Huffman Coding? Huffman Coding is a greedy algorithm used to compress data without losing any information. The idea is simple:
Assign shorter codes to more frequent characters and longer codes to less frequent ones. Ever tried zipping a file to save space? That magic trick behind the scenes? That’s compression — and Huffman Coding is one of the smartest ways to pull it off.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-06T00:46:56+05:00">
    <meta property="article:modified_time" content="2025-05-06T00:46:56+05:00">
    <meta property="article:tag" content="Huffman">
    <meta property="article:tag" content="Algorithm">
    <meta property="article:tag" content="Ubuntu">
    <meta property="article:tag" content="Greedy">
    <meta property="article:tag" content="Coding">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Huffman Coding: The Art of Compression">
<meta name="twitter:description" content="In a world drowning in data, how do we store and transmit information more efficiently? The answer lies in Huffman Coding — a beautifully simple yet powerful algorithm used for lossless data compression. It&rsquo;s been a cornerstone since it was introduced.

What Is Huffman Coding?
Huffman Coding is a greedy algorithm used to compress data without losing any information. The idea is simple:
Assign shorter codes to more frequent characters and longer codes to less frequent ones.
Ever tried zipping a file to save space? That magic trick behind the scenes? That’s compression — and Huffman Coding is one of the smartest ways to pull it off.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://AnohbaJhd.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Huffman Coding: The Art of Compression",
      "item": "https://AnohbaJhd.github.io/posts/huffman/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Huffman Coding: The Art of Compression",
  "name": "Huffman Coding: The Art of Compression",
  "description": "In a world drowning in data, how do we store and transmit information more efficiently? The answer lies in Huffman Coding — a beautifully simple yet powerful algorithm used for lossless data compression. It\u0026rsquo;s been a cornerstone since it was introduced.\nWhat Is Huffman Coding? Huffman Coding is a greedy algorithm used to compress data without losing any information. The idea is simple:\nAssign shorter codes to more frequent characters and longer codes to less frequent ones. Ever tried zipping a file to save space? That magic trick behind the scenes? That’s compression — and Huffman Coding is one of the smartest ways to pull it off.\n",
  "keywords": [
    "huffman", "algorithm", "ubuntu", "greedy", "coding"
  ],
  "articleBody": "In a world drowning in data, how do we store and transmit information more efficiently? The answer lies in Huffman Coding — a beautifully simple yet powerful algorithm used for lossless data compression. It’s been a cornerstone since it was introduced.\nWhat Is Huffman Coding? Huffman Coding is a greedy algorithm used to compress data without losing any information. The idea is simple:\nAssign shorter codes to more frequent characters and longer codes to less frequent ones. Ever tried zipping a file to save space? That magic trick behind the scenes? That’s compression — and Huffman Coding is one of the smartest ways to pull it off.\nIt’s like using nicknames. Instead of saying “Jonathanathan” every time, you just say “Jon”. Saves time. Saves space. No information lost. That’s the Huffman vibe.\nIt uses a binary tree structure to build optimal prefix codes (no code is a prefix of another), ensuring efficient encoding and decoding.\nTerminologies Term What It Means Character Frequency How many times a character appers in the text. Leaf Node A tree piece that holds a character. It has no children. Internal Node A tree piece that connects other nodes. It doesn’t hold a character. Root Node The top part of the tree that connects everything. Min Heap A list that always gives the smallest number first. Binary Code Assignment Left turn = 0, right turn = 1. Used to make codes from the tree. Prefix-Free Code No code starts the same as another, so there’s no confusion when reading. Compression Making data smaller so it takes up less space. How It Works (Step-by-Step) Calculate Frequencies\nCount how many times each character appears in the input data.\nBuild a Priority Queue\nEach character becomes a leaf node with its frequency as weight.\nBuild the Huffman Tree\nRepeatedly:\nTake two lowest-frequency nodes, Combine them into a new node with the sum of their frequencies, Insert the new node back into the queue. Continue until only one node (the root) is left. Assign Binary Codes\nTraverse the tree:\nGo left ➡️ append 0 Go right ➡️ append 1 Example Let’s take a simple string:\n\"beep boop beer\" We’ll walk through how Huffman compresses this.\nStep 1: Frequency Count We start by counting the frequency of each character in the string “beep boop beer”:\nb: 3 e: 4 o: 2 p: 2 r: 1 (space): 2 These frequencies help us decide which characters should get short or long codes.\nStep 2: Build a Min Heap Next, we create a Min Heap (priority queue) from the characters and their frequencies:\n[ r:1, o:2, p:2, (space):2, b:3, e:4 ]\nWe repeatedly take out the two lowest frequency nodes, combine them, and put the result back into the heap. This process eventually forms our Huffman Tree.\nStep 3: Create the Huffman Tree Keep merging the two smallest nodes until only one node (the root) remains. Let’s say we get this structure:\nStep 4: Assign Binary Codes Now, we traverse the tree and assign binary codes. The rule is:\nLeft = 0 Right = 1 From the tree, we get the following codes:\ne → 10 b → 11 (space) → 000 p → 001 r → 1000 o → 1001 (Note: The exact codes may vary depending on how the tree was built, but they will always be prefix-free.)\nStep 5: Encode the Original String Let’s encode the original string “beep boop beer” using the Huffman codes:\nOriginal:\nb e e p b o o p b e e r\nUsing the codes:\nb → 11 e → 10 p → 001 (space) → 000 o → 1001 r → 1000\nSo, we get the following binary string: 11 10 10 001 11 1001 1001 001 11 10 10 1000\nFinal Binary String: 111010001111001100100010010110101000\nThis is much smaller than using 8-bit ASCII per character.\nWhere Is Huffman Coding Used? Huffman coding is used extensively in:\nFile Compression: Formats like .zip, .gz Image Compression: JPEG (in entropy encoding stage) Video Compression: MPEG, H.264 codecs Text Compression: Unix compress, PDF text compression Data transmission: When minimizing bandwidth is critical Advantages Lossless Compression — No data is lost during encoding.\nOptimal for symbol-by-symbol encoding — Based on frequency.\nFast and Simple — Efficient in both compression and decompression.\nPrefix-free codes — No ambiguity during decoding.\nDisadvantages Requires Frequency Table — Needs to be stored/sent along with compressed data.\nNot Always Best — For small data sets or near-uniform frequencies, it might not compress well.\nStatic — Doesn’t adapt to changing data unless used in a dynamic/adaptive version.\nTree Overhead — Storing the tree adds some overhead for very small inputs.\nWhen Not to Use Huffman Coding If you’re compressing already compressed files (like .mp4, .png) When your data has very little redundancy If you’re aiming for real-time compression with fast, adaptive techniques (like Arithmetic or LZ-based compression) Conclusion Huffman Coding remains one of the most elegant examples of how theory meets practicality. It teaches us the value of frequency, greedy algorithms, and efficient data structures — all wrapped in a sweet little binary tree.\nWhether you’re building your own compression tool, diving into how JPEG works, or just brushing up for a comp-sci interview, Huffman Coding is a must-know classic.\n“The art of programming is the art of organizing complexity.” — Edsger Dijkstra\n",
  "wordCount" : "887",
  "inLanguage": "en",
  "datePublished": "2025-05-06T00:46:56+05:00",
  "dateModified": "2025-05-06T00:46:56+05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://AnohbaJhd.github.io/posts/huffman/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Anohba Jehad",
    "logo": {
      "@type": "ImageObject",
      "url": "https://AnohbaJhd.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://AnohbaJhd.github.io/" accesskey="h" title="Anohba Jehad (Alt + H)">Anohba Jehad</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://AnohbaJhd.github.io/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://AnohbaJhd.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://AnohbaJhd.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://AnohbaJhd.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Huffman Coding: The Art of Compression
    </h1>
    <div class="post-meta"><span title='2025-05-06 00:46:56 +0500 PKT'>May 6, 2025</span>&nbsp;·&nbsp;5 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#what-is-huffman-coding" aria-label="What Is Huffman Coding?">What Is Huffman Coding?</a></li></ul>
                    
                <li>
                    <a href="#terminologies" aria-label="Terminologies">Terminologies</a><ul>
                        
                <li>
                    <a href="#how-it-works-step-by-step" aria-label="How It Works (Step-by-Step)">How It Works (Step-by-Step)</a></li>
                <li>
                    <a href="#example" aria-label="Example">Example</a><ul>
                        
                <li>
                    <a href="#step-1-frequency-count" aria-label="Step 1: Frequency Count">Step 1: Frequency Count</a></li>
                <li>
                    <a href="#step-2-build-a-min-heap" aria-label="Step 2: Build a Min Heap">Step 2: Build a Min Heap</a></li>
                <li>
                    <a href="#step-3-create-the-huffman-tree" aria-label="Step 3: Create the Huffman Tree">Step 3: Create the Huffman Tree</a></li>
                <li>
                    <a href="#step-4-assign-binary-codes" aria-label="Step 4: Assign Binary Codes">Step 4: Assign Binary Codes</a></li>
                <li>
                    <a href="#step-5-encode-the-original-string" aria-label="Step 5: Encode the Original String">Step 5: Encode the Original String</a></li>
                <li>
                    <a href="#final-binary-string" aria-label="Final Binary String:">Final Binary String:</a></li></ul>
                </li>
                <li>
                    <a href="#where-is-huffman-coding-used" aria-label="Where Is Huffman Coding Used?">Where Is Huffman Coding Used?</a></li>
                <li>
                    <a href="#advantages" aria-label="Advantages">Advantages</a></li>
                <li>
                    <a href="#disadvantages" aria-label="Disadvantages">Disadvantages</a></li>
                <li>
                    <a href="#when-not-to-use-huffman-coding" aria-label="When Not to Use Huffman Coding">When Not to Use Huffman Coding</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>In a world drowning in data, how do we store and transmit information more efficiently? The answer lies in <em>Huffman Coding</em> — a beautifully simple yet powerful algorithm used for <strong>lossless data compression</strong>. It&rsquo;s been a cornerstone since it was introduced.</p>
<hr>
<h2 id="what-is-huffman-coding">What Is Huffman Coding?<a hidden class="anchor" aria-hidden="true" href="#what-is-huffman-coding">#</a></h2>
<p>Huffman Coding is a <strong>greedy algorithm</strong> used to compress data without losing any information. The idea is simple:<br>
<strong>Assign shorter codes to more frequent characters and longer codes to less frequent ones.</strong>
Ever tried zipping a file to save space? That magic trick behind the scenes? That’s compression — and Huffman Coding is one of the smartest ways to pull it off.</p>
<p>It’s like using nicknames. Instead of saying &ldquo;Jonathanathan&rdquo; every time, you just say &ldquo;Jon&rdquo;. Saves time. Saves space. No information lost. That&rsquo;s the Huffman vibe.</p>
<p>It uses a <strong>binary tree structure</strong> to build optimal prefix codes (no code is a prefix of another), ensuring efficient encoding and decoding.</p>
<hr>
<h1 id="terminologies">Terminologies<a hidden class="anchor" aria-hidden="true" href="#terminologies">#</a></h1>
<table>
  <thead>
      <tr>
          <th>Term</th>
          <th>What It Means</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Character Frequency</strong></td>
          <td>How many times a character appers in the text.</td>
      </tr>
      <tr>
          <td><strong>Leaf Node</strong></td>
          <td>A tree piece that holds a character. It has no children.</td>
      </tr>
      <tr>
          <td><strong>Internal Node</strong></td>
          <td>A tree piece that connects other nodes. It doesn&rsquo;t hold a character.</td>
      </tr>
      <tr>
          <td><strong>Root Node</strong></td>
          <td>The top part of the tree that connects everything.</td>
      </tr>
      <tr>
          <td><strong>Min Heap</strong></td>
          <td>A list that always gives the smallest number first.</td>
      </tr>
      <tr>
          <td><strong>Binary Code Assignment</strong></td>
          <td>Left turn = 0, right turn = 1. Used to make codes from the tree.</td>
      </tr>
      <tr>
          <td><strong>Prefix-Free Code</strong></td>
          <td>No code starts the same as another, so there&rsquo;s no confusion when reading.</td>
      </tr>
      <tr>
          <td><strong>Compression</strong></td>
          <td>Making data smaller so it takes up less space.</td>
      </tr>
  </tbody>
</table>
<h2 id="how-it-works-step-by-step">How It Works (Step-by-Step)<a hidden class="anchor" aria-hidden="true" href="#how-it-works-step-by-step">#</a></h2>
<ol>
<li>
<p><strong>Calculate Frequencies</strong><br>
Count how many times each character appears in the input data.</p>
</li>
<li>
<p><strong>Build a Priority Queue</strong><br>
Each character becomes a leaf node with its frequency as weight.</p>
</li>
<li>
<p><strong>Build the Huffman Tree</strong><br>
Repeatedly:</p>
<ul>
<li>Take two lowest-frequency nodes,</li>
<li>Combine them into a new node with the sum of their frequencies,</li>
<li>Insert the new node back into the queue.
Continue until only one node (the root) is left.</li>
</ul>
</li>
<li>
<p><strong>Assign Binary Codes</strong><br>
Traverse the tree:</p>
<ul>
<li>Go left ➡️ append <code>0</code></li>
<li>Go right ➡️ append <code>1</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="example">Example<a hidden class="anchor" aria-hidden="true" href="#example">#</a></h2>
<p>Let’s take a simple string:</p>
<pre tabindex="0"><code>&#34;beep boop beer&#34;
</code></pre><p>We’ll walk through how Huffman compresses this.</p>
<h3 id="step-1-frequency-count">Step 1: Frequency Count<a hidden class="anchor" aria-hidden="true" href="#step-1-frequency-count">#</a></h3>
<p>We start by counting the frequency of each character in the string &ldquo;beep boop beer&rdquo;:</p>
<ul>
<li><code>b</code>: 3</li>
<li><code>e</code>: 4</li>
<li><code>o</code>: 2</li>
<li><code>p</code>: 2</li>
<li><code>r</code>: 1</li>
<li>(space): 2</li>
</ul>
<p>These frequencies help us decide which characters should get short or long codes.</p>
<h3 id="step-2-build-a-min-heap">Step 2: Build a Min Heap<a hidden class="anchor" aria-hidden="true" href="#step-2-build-a-min-heap">#</a></h3>
<p>Next, we create a <strong>Min Heap</strong> (priority queue) from the characters and their frequencies:</p>
<p>[ r:1, o:2, p:2, (space):2, b:3, e:4 ]</p>
<p>We repeatedly take out the two lowest frequency nodes, combine them, and put the result back into the heap. This process eventually forms our <strong>Huffman Tree</strong>.</p>
<h3 id="step-3-create-the-huffman-tree">Step 3: Create the Huffman Tree<a hidden class="anchor" aria-hidden="true" href="#step-3-create-the-huffman-tree">#</a></h3>
<p>Keep merging the two smallest nodes until only one node (the <strong>root</strong>) remains. Let’s say we get this structure:</p>
<p><img alt="Structure screenshot" loading="lazy" src="/huffman/s1.png"></p>
<h3 id="step-4-assign-binary-codes">Step 4: Assign Binary Codes<a hidden class="anchor" aria-hidden="true" href="#step-4-assign-binary-codes">#</a></h3>
<p>Now, we traverse the tree and assign binary codes. The rule is:</p>
<ul>
<li>Left = <code>0</code></li>
<li>Right = <code>1</code></li>
</ul>
<p>From the tree, we get the following codes:</p>
<ul>
<li><code>e → 10</code></li>
<li><code>b → 11</code></li>
<li><code>(space) → 000</code></li>
<li><code>p → 001</code></li>
<li><code>r → 1000</code></li>
<li><code>o → 1001</code></li>
</ul>
<p>(Note: The exact codes may vary depending on how the tree was built, but they will always be <strong>prefix-free</strong>.)</p>
<h3 id="step-5-encode-the-original-string">Step 5: Encode the Original String<a hidden class="anchor" aria-hidden="true" href="#step-5-encode-the-original-string">#</a></h3>
<p>Let’s encode the original string <strong>&ldquo;beep boop beer&rdquo;</strong> using the Huffman codes:</p>
<p>Original:<br>
b e e p b o o p b e e r</p>
<p>Using the codes:<br>
b → 11
e → 10
p → 001
(space) → 000
o → 1001
r → 1000</p>
<p>So, we get the following binary string:
11 10 10 001 11 1001 1001 001 11 10 10 1000</p>
<h3 id="final-binary-string">Final Binary String:<a hidden class="anchor" aria-hidden="true" href="#final-binary-string">#</a></h3>
<p>111010001111001100100010010110101000</p>
<p>This is much smaller than using <strong>8-bit ASCII</strong> per character.</p>
<hr>
<h2 id="where-is-huffman-coding-used">Where Is Huffman Coding Used?<a hidden class="anchor" aria-hidden="true" href="#where-is-huffman-coding-used">#</a></h2>
<p>Huffman coding is used extensively in:</p>
<ul>
<li><strong>File Compression</strong>: Formats like <code>.zip</code>, <code>.gz</code></li>
<li><strong>Image Compression</strong>: JPEG (in entropy encoding stage)</li>
<li><strong>Video Compression</strong>: MPEG, H.264 codecs</li>
<li><strong>Text Compression</strong>: Unix <code>compress</code>, PDF text compression</li>
<li><strong>Data transmission</strong>: When minimizing bandwidth is critical</li>
</ul>
<hr>
<h2 id="advantages">Advantages<a hidden class="anchor" aria-hidden="true" href="#advantages">#</a></h2>
<p><strong>Lossless Compression</strong> — No data is lost during encoding.<br>
<strong>Optimal for symbol-by-symbol encoding</strong> — Based on frequency.<br>
<strong>Fast and Simple</strong> — Efficient in both compression and decompression.<br>
<strong>Prefix-free codes</strong> — No ambiguity during decoding.</p>
<hr>
<h2 id="disadvantages">Disadvantages<a hidden class="anchor" aria-hidden="true" href="#disadvantages">#</a></h2>
<p><strong>Requires Frequency Table</strong> — Needs to be stored/sent along with compressed data.<br>
<strong>Not Always Best</strong> — For small data sets or near-uniform frequencies, it might not compress well.<br>
<strong>Static</strong> — Doesn’t adapt to changing data unless used in a dynamic/adaptive version.<br>
<strong>Tree Overhead</strong> — Storing the tree adds some overhead for very small inputs.</p>
<hr>
<h2 id="when-not-to-use-huffman-coding">When <em>Not</em> to Use Huffman Coding<a hidden class="anchor" aria-hidden="true" href="#when-not-to-use-huffman-coding">#</a></h2>
<ul>
<li>If you&rsquo;re compressing <strong>already compressed files</strong> (like <code>.mp4</code>, <code>.png</code>)</li>
<li>When your data has <strong>very little redundancy</strong></li>
<li>If you&rsquo;re aiming for <strong>real-time compression</strong> with fast, adaptive techniques (like Arithmetic or LZ-based compression)</li>
</ul>
<hr>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Huffman Coding remains one of the most elegant examples of how theory meets practicality. It teaches us the value of <strong>frequency</strong>, <strong>greedy algorithms</strong>, and <strong>efficient data structures</strong> — all wrapped in a sweet little binary tree.</p>
<p>Whether you’re building your own compression tool, diving into how JPEG works, or just brushing up for a comp-sci interview, Huffman Coding is a must-know classic.</p>
<blockquote>
<p>“The art of programming is the art of organizing complexity.” — Edsger Dijkstra</p></blockquote>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://AnohbaJhd.github.io/tags/huffman/">Huffman</a></li>
      <li><a href="https://AnohbaJhd.github.io/tags/algorithm/">Algorithm</a></li>
      <li><a href="https://AnohbaJhd.github.io/tags/ubuntu/">Ubuntu</a></li>
      <li><a href="https://AnohbaJhd.github.io/tags/greedy/">Greedy</a></li>
      <li><a href="https://AnohbaJhd.github.io/tags/coding/">Coding</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://AnohbaJhd.github.io/">Anohba Jehad</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
